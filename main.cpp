#include <iostream>
#include <math.h>
#include <stdlib.h>
#include <fstream>

using namespace std;

double sign(double x) {
    if (x == 0.0) return 0;
    if (x > 0.0) return 1;
    else return -1;
}

int main() {
    int n, m;
    system("chcp 65001");
    ifstream f("matrix.txt");
    f >> n;
    m = n + 1;                      //Расширенная матрица
    double **A = new double *[n+1]; //Выделяем память под строки
    for (int i = 1; i <= n; i++)
        A[i] = new double[m+1];     //Под столбцы
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            f >> A[i][j];
        }
    }
    f.close();

    //Вывод на экран
    cout << "Матрица A: " << endl;
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++){
            if (j == m) cout << "|";
            cout << A[i][j] << " ";
    }
        cout << endl;
    }
    cout << endl;

/*    A = S*DS,
      S — верхняя треугольная матрица с положительными элементами на главной диагонали,
      S*— транспонированная матрица S,
      D — диагональная матрица, на диагонали которой находятся числа, равные ± 1
                                                                                             */
    double S[n + 1][n + 1];   //Описываем матрицу S
    double D[n + 1][n + 1];   //Описываем матрицу D

/*------------------------Инициализация первых элементов матриц S и D------------------------*/
    S[1][1] = sqrt(abs(A[1][1]));
    D[1][1] = sign(A[1][1]);
    for(int j = 2; j <= n; ++j) {
        S[1][j] = A[1][j] / (S[1][1] * D[1][1]);
    }
/*Все элементы матрицы S считаются по следующей схеме:
   s[i,j]= (A[i,j] - sum(от l=1 до l=i-1)(s[l,i]*s[l,j]*D[l,l]))/s[i,i]*D[i,i]        
  А все элементы диагональной матрицы D считаются следующим образом:
   D[i,i]= sign(A[i,j] - sum(от l=1 до l=i-1)(S[l][i] * S[l][i] * D[l][l]
/*------------------------  Инициализация первых элементов матриц S и D------------------------*/

/*------------------------Расчитывамем все оставшиеся значения S и D------------------------*/
    for(int i = 2; i <= n; ++i) {
        double sum = 0;
        for (int l = 1; l <= i - 1; ++l)
            sum = sum + S[l][i] * S[l][i] * D[l][l];
        S[i][i] = sqrt(abs(A[i][i] - sum));
        D[i][i] = sign(A[i][i] - sum);
        for (int j = i + 1; j <= n; ++j) {
            sum = 0;
            for (int l = 1; l <= i - 1; l++) {
                sum = sum + S[l][i] * S[l][j] * D[l][l];
            }
            S[i][j] = (A[i][j] - sum) / (S[i][i]* D[i][i]);
        }
    }
/*------------------------Расчитывамем все оставшиеся значения S и D------------------------*/

/*Выводим матрицу после прямого хода, чтобы проверить, что она была приведена
     к ступенчатому виду
  Так как счет идет с ошибкой вычисления, то для наглядности занулим то,
   что находится ниже главной диагонали, а также проверим вектор правой части на наличие
    цифр с ошибкой вычисления                                                       */

    cout <<"Главная диагональ матрицы D:" <<endl;
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= n; j++)
            if (abs(S[i][j]) < 0.000001) S[i][j] = 0;

    for (int i = 1; i <= n; i++) {
        cout << D[i][i] << " ";
    }
    cout << endl;
    cout <<"Полученная матрица S:" <<endl;
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++)
            cout << S[i][j] << " ";
        cout << endl;
    }
    cout<<endl;


/*Итак, если после предыдущих действий имеем матрицу S. Чтобы довести решение
   нам требуется представить исходную матрицу в виде:
             A = S*S, где S* - транспонированная матрица S
  Не будем совершать лишних действий по выделению памяти под новую матрицу,
   а просто поменяем местами индексы у матрицы S[i,j] местами, это и будет S*.
                                                                                */

/*-------------------------------------Обратный ход-------------------------------------*/
/*Обратный ход состоит в в последовательном решении двух систем уравнений
                             (1) S*y = f
   где f это последний столбец в расширенной матрице (вектор)
   в нашем случае это переменная вида A[i,m], где m это последний стобец матрицы
   Формула для нахождения y[i]
        y[i] = (f[i] - sum(от l=1 до l=i-1)(s[l,i]*y[l]))/s[i,i], где i = 2,3,..,m
                                                                                   */
    double y[n + 1];
    y[1] = A[1][m] / S[1][1]* D[1][1];        //y[1] всегда равен f[1]/s[1,1]
    for(int i = 2; i <= n; ++i) {
        double sum = 0;
        for (int l = 1; l <= i - 1; ++l)
            sum = sum + S[l][i] * y[l]* D[l][l];
        y[i] = (A[i][m] - sum) / (S[i][i]* D[i][i]);
    }
    cout <<"Вектор y:" <<endl;
    for(int i = 1; i <= n; ++i) {
        cout <<y[i] << ' ';
    }
    cout <<endl;

/*Используя значения y, найденные в предыдущем уравнении, решаем второе уравнение
                             (2) Sx = y
   формула для нахождения x[i]
        x[i] = (y[i] - sum(от l=1+1 до l=i)(s[i,l]*x[l]))/s[i,i], гдн i = i-1,i-2,..,1
                                                                                        */
    double x[n + 1];
    x[n] = y[n] / S[n][n];           //Последний x[n] всегда равен u[n]/s[n,n]
    for(int i = n - 1; i >= 1; --i) {
        double sum = 0;
        for (int l = i + 1; l <= n; ++l)
            sum = sum + S[i][l] * x[l];
        x[i] = (y[i] - sum) / S[i][i];
    }
/*---------------------------------------Обратный ход--------------------------------------*/

    //Выводим решения
    ofstream out ("answer.txt");
    cout <<endl <<"Ответ" <<endl;
    for (int i = 1; i <= n; i++) {
        cout << x[i] << " ";
        out << x[i] << ' ';
    }
    out.close();
    delete[] A;
    return 0;
}
